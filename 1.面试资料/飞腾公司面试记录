我们的后台检测线程采用了状态机协调机制：

每次轮询前检查 class_current_status，只有在 IDLE 状态下才执行自动检测
手动操作通过Netlink更新状态为 LOAD/UNLOAD 等非IDLE状态
后台线程检测到非IDLE状态会 continue 跳过，避免冲突
CPLD硬件操作使用 mutex 加锁，防止并发冲突
还有超时保护机制，防止状态机死锁"

采用的是Netlink的方式

Netlink	内核?用户态	异步、双向、高效	? 使用
ioctl	内核?用户态	同步、简单命令	? 不够灵活
sysfs	用户态读取内核	只读配置	? 无法执行复杂操作
procfs	用户态读取内核	读取信息	? 不适合控制
信号(signal)	内核通知用户态	简单通知	? 数据量小

┌────────────────────────────────────────────────────────┐
│ Step 1: 用户在CLI输入命令                           │
├────────────────────────────────────────────────────────┤
│ cli_hotplug_load_subcard()                         │
│   ├─ 解析 slot0         
│   └─ 调用 sph_subcard_load_subcard(0)             │
└────────────────────────────────────────────────────────┘
                   ↓
┌────────────────────────────────────────────────────────┐
│ Step 2: 用户态准备Netlink消息                       │
├────│ ipc_msg_t cb;                                     │
│ sph_query_info_msg_t *msg = malloc(...);            │
│ msg->slot_num = 0;                                │
│                                                  │
│ INIT_MSG(&cb, CMD_SPH_LOAD_SUBCARD, MOD_ID_SPH, msg, len)│
└────────────────────────────────────────────────────────┘
                   ↓
┌────────────────────────────────────────────────────────┐
│ Step 3: 通过Netlink发送到内核                       │
├────────────────────────
│ nl_rpc_trans(&cb, NULL);                           │
│   ↓                                               │
│ [Netlink Socket发送] → 内核Netlink子系统            │
└────────────────────────────────────────────────────────┘
┌────────────────────────────────────────────────────────┐
│ Step 4: 内核接收并分发消息                          │
├────────────────────────────────────────────────────────┤
│ netlink内核层                                      │
│   ├─ 接收消息  
解析 msg_type = CMD_SPH_LOAD_SUBCARD          │
│   └─ 调用 sph_cli_msg_proc(&cb, pid)            
┌────────────────────────────────────────────────────────┐
│ Step 5: 内核处理消息                               │
├────────────────────────────────────────────────────────┤
│ sph_cli_msg_proc() {                               │
│     switch (msg->msg_type) {                        │
│         case CMD_SPH_LOAD_SUBCARD:                   │
│             local_sph_class->hotplug_load_subcard(msg);│
│             break;                                  │
│     } 
┌────────────────────────────────────────────────────────┐
│ Step 6: 执行热插拔操作                              │
├────────────────────────────────────────────────────────┤
│ class_hotplug_load_subcard() {                      │
│     ├─ 检查状态   
├─ CPLD上电                                    │
│     ├─ PCI rescan                                  │
│     └─ 返回结果                                   │
│ }  
                   ↓
┌────────────────────────────────────────────────────────┐
│ Step 7: 内核返回结果                               │
├────────────────────────────────────────────────────────┤
│ cb.result = S_OK 或 S_ERR                          │
│ c b.data = 返回数据（如果有）                        │
└────────────────────────────────────────────────────────┘    
┌────────────────────────────────────────────────────────┐
│ Step 8: 用户态接收结果                             │
├────────────────────────────────────────────────────────┤
│ ret = nl_rpc_trans(...)                            │
│ // 等待内核返回（阻塞或非阻塞） 
 if (ret == S_OK) {                                │
│     printf("Load subcard success!\n");               │
│ } else {                                          │
│     printf("Load failed: %d\n", ret);              │
│ }                                                                        │                                              