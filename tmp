你好，之前是服务器公司研发部门软件研发工程师，贵司考虑无销售经验工程师投递简历吗


第三阶段：深入 ―― 核心代码阅读路线（按此顺序）
现在可以打开你的源码了。建议聚焦于一个主线内核版本（如你下载的版本）。

路线图：从用户态调用到硬件访问
入口：/drivers/pci/ 目录

这是PCI子系统核心所在。不要一开始就看这里的具体实现，先看头文件。

头文件概览：

include/linux/pci.h：最重要的头文件。定义了所有关键数据结构（struct pci_dev, struct pci_bus, struct pci_driver）和API函数原型（pci_read_config_xxx, pci_enable_device等）。反复看，把这些结构和API印在脑子里。

include/uapi/linux/pci_regs.h：定义了PCI配置空间的所有标准寄存器偏移量和位域（如 PCI_VENDOR_ID, PCI_BASE_ADDRESS_0）。这是内核与PCI标准的接口。

核心初始化与枚举流程（理解“ PCI 设备是怎么被内核发现的”）：

起点：内核启动时，架构相关代码会调用PCI子系统初始化。

对于x86，查看 arch/x86/pci/ 目录，尤其是 init.c 或 common.c 中的 pci_legacy_init 或 pci_subsys_init。

核心枚举：关键函数是 pci_scan_bridge() 和 pci_scan_slot()。它们会递归地扫描PCI总线。

调用链建议（在你的IDE中用cscope追）：

text
start_kernel -> arch_call_rest_init -> ... -> pci_subsys_init -> pci_legacy_init
-> pcibios_scan_root -> pci_scan_root_bus -> ...
目标：不要求理解每一行，但要理清大致的函数调用关系和“扫描总线-发现设备-创建pci_dev”这个主流程。

资源分配：

设备被发现后，内核需要为它的BAR分配内存/IO空间。查看 pci_assign_resource() 和相关函数。理解 proc/iomem 和 proc/ioports 的输出与这里的关系。

驱动匹配与probe：

这是你写驱动时接触的部分。追踪一个PCI驱动是如何通过 pci_register_driver() 注册，其 .id_table 如何与设备匹配，最终调用到驱动自己的 .probe 方法。

看一个简单真实的驱动例子，比如 drivers/misc/eeprom/ 下的 eeprom 驱动。

配置空间访问的底层实现：

这是连接软件和硬件的最后一步。函数如 pci_read_config_dword() 最终会调用 struct pci_ops 里的函数。

对于x86，这个底层操作在 arch/x86/pci/direct.c 或 early.c 中，最终会使用 IN/OUT 指令或MMIO访问 0xCF8, 0xCFC 这两个I/O端口。理解这个机制就打通了任督二脉。

第四阶段：实践与深化
使用QEMU调试：

这是终极学习神器。用QEMU启动一个Linux内核，并添加 -device pci-bridge,id=br0 -device e1000,bus=br0 等参数来添加虚拟PCI设备。

结合 gdb 和QEMU的 -s -S 参数，单步跟踪PCI的初始化代码！亲眼看到数据结构的变化，理解是无法比拟的。

给内核打补丁：

尝试修改PCI核心代码中的某个打印信息（比如在 pci_scan_device 里加一句 printk），重新编译内核，在QEMU里运行，验证你的修改。这会让你熟悉内核编译和测试流程。

阅读优秀、简单的PCI驱动：

例如：drivers/char/ 下的 lp-pci（并口卡驱动），代码相对短小，包含了完整的PCI驱动框架。

根总线初始化：

pci_create_bus() 创建根总线（Root Bus），设置 resource[0/1] 和 secondary。
根总线加入 pci_root_buses 链表。
枚举子总线与设备：

pci_scan_child_bus() 递归扫描所有设备。
对桥接器调用 pci_create_bus() 创建子总线。
对终端设备调用 pci_scan_device() 分配资源。
资源分配与驱动绑定：

所有设备的 BAR（Base Address Register）通过 resource[0/1] 分配物理地址。
驱动通过 pci_register_driver() 注册，与设备匹配。

黄浜益
Linux 研发工程师 | 3年经验 | 浙江宇视 (Uniview) 背景
? 意向城市：长沙  | ? 17670533280  | ? 1005hby@gmail.com 
+1

? 职业亮点

深耕存储底层：3年知名安防企业（宇视科技）嵌入式驱动开发经验，主攻存储服务器底层维护与开发 。


全栈底层视角：具备从 BIOS 预留、内核资源分配到用户态接口调用的全链路开发能力 。



项目领导力：曾担任 PCIe 热插拔专项负责人，具备从需求分析到交付的全流程管理经验 。



AI 赋能研发：熟练运用 DeepSeek/ChatGPT 等工具编写自动化测试脚本，显著提升开发效率 。


? 专业技能

核心语言：精通 C 语言、Shell 脚本开发，熟悉常用数据结构与算法 。
+1


内核驱动：深入理解 Linux 内核架构，精通 PCIe、SATA、I2C 协议及底层驱动适配 。
+2


系统集成：具备内核剪裁、内存文件系统适配、升级镜像模块修改等定制化经验 。


行业理解：熟悉安防产品线，对存储服务器硬件迭代及国产化芯片适配有实战经验 。
+1


通用能力：可流畅阅读英文技术文档，具备跨团队协同与抗压能力 。
+1

? 工作经历
浙江宇视科技有限公司 | 嵌入式驱动工程师 2022/08 - 至今 
+1


底层适配：负责存储服务器芯片迭代时的驱动适配，及操作系统切换时的内核/系统剪裁 。


定制化开发：根据软硬件需求，完成底层功能的定制开发与维护 。


技术沉淀：深入研究 PCIe 协议及 Linux 文件系统接口，解决底层稳定性问题 。
+1

? 项目经验
1. 
PCIe 热插拔功能开发 (项目负责人) 

2025/02 - 至今 


项目职责：负责需求分析、计划制定及任务下发，主导重难点技术突破 。

核心实现：


应用层：设计用户态主程序，通过调用 FS 注册的 remove/rescan 接口实现设备交互 。


文件系统层：实现 PCI 信息获取、扫描移除逻辑，并通过 CPLD/I2C 实现槽位上下电控制 。


内核层：实现设备扫描与资源申请分配机制，完成子卡驱动接口注册 。


BIOS/硬件层：协同实现 BIOS 上行口预留及硬件层面的热插拔支持 。
+1


项目成果：成功实现存储设备 PCIe 动态扩展能力，公司级项目奖（申报中） 。
+1

2. 
存储产品硬件迭代项目 (核心成员) 

2022/10 - 2024/11 


技术攻关：负责内核裁剪与内存文件系统适配，确保新硬件平台的系统稳定性 。


效率提升：利用 AI 工具 辅助编写自动化测试脚本，缩短了版本迭代的测试周期 。


获得荣誉：凭借技术攻坚获得 个人“技术突破奖” 及 团队“卓越执行奖” 。
+1

? 教育背景
湖南农业大学 | 物联网工程 | 本科 2018/09 - 2022/06 
+1


成绩：GPA 3.3 (专业前 30%) 。


核心课程：C 程序设计、嵌入式 Linux 应用开发、数据结构、计算机网络 。

? 其他信息

自我驱动：具备强烈的学习意识，热爱阅读心理学书籍，关注个人成长 。


生活平衡：热爱羽毛球、网球等球类运动，保持良好的体能与心态 。